## Опис домашнього завдання

У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет `[50, 25, 10, 5, 2, 1]`. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

1. Функція жадібного алгоритму `find_coins_greedy`. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник `{50: 2, 10: 1, 2: 1, 1: 1}`. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

2. Функція динамічного програмування `find_min_coins`. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник `{1: 1, 2: 1, 10: 1, 50: 2}`

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл `readme.md` домашнього завдання.

## Критерії прийняття ДЗ

- Прикріплені посилання на репозиторій `goit-algo-hw-09` та безпосередньо сам файл репозиторію у форматі `zip`.
- Програмно реалізовано функцію, яка використовує принцип жадібного алгоритму. Код виконується і повертає словник з кількістю монет кожного номіналу, що використовуються для формування певної суми. Спочатку вибираються найбільш доступні номінали монет.
- Програмно реалізовано функцію, яка використовує принцип динамічного програмування. Код виконується і повертає словник з номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом.
- На основі оцінювання часу виконання кожного з двох алгоритмів або О великого визначено найбільш ефективний при великих сумах алгоритм.
- Зроблено висновки щодо ефективності алгоритмів для даного випадку. Висновки оформлено у вигляді файлу `readme.md` домашнього завдання.

# Висновки щодо ефективності алгоритмів

## Порівняння жадібного алгоритму та алгоритму динамічного програмування

Для різних сум ми виконали два алгоритми: жадібний алгоритм та алгоритм динамічного програмування. Результати та час виконання для кожної суми наведено в таблицях нижче.

### Сума: 113

| Алгоритм                | Результат                                               | Час виконання (секунди) |
|-------------------------|---------------------------------------------------------|--------------------------|
| Жадібний алгоритм       | Номінал: 50 - 2шт, 10 - 1шт, 2 - 1шт, 1 - 1шт           | 0.0                      |
| Динамічне програмування | Номінал: 50 - 2шт, 10 - 1шт, 2 - 1шт, 1 - 1шт           | 0.0                      |

### Сума: 289

| Алгоритм                | Результат                                               | Час виконання (секунди) |
|-------------------------|---------------------------------------------------------|--------------------------|
| Жадібний алгоритм       | Номінал: 50 - 5шт, 25 - 1шт, 10 - 1шт, 2 - 2шт          | 0.0                      |
| Динамічне програмування | Номінал: 50 - 5шт, 25 - 1шт, 10 - 1шт, 2 - 2шт          | 0.0                      |

### Сума: 523

| Алгоритм                | Результат                                               | Час виконання (секунди) |
|-------------------------|---------------------------------------------------------|--------------------------|
| Жадібний алгоритм       | Номінал: 50 - 10шт, 10 - 2шт, 2 - 1шт, 1 - 1шт          | 0.0                      |
| Динамічне програмування | Номінал: 50 - 10шт, 10 - 2шт, 2 - 1шт, 1 - 1шт          | 0.0                      |

### Сума: 999

| Алгоритм                | Результат                                               | Час виконання (секунди)  |
|-------------------------|---------------------------------------------------------|--------------------------|
| Жадібний алгоритм       | Номінал: 50 - 19шт, 25 - 1шт, 10 - 2шт, 2 - 2шт         | 0.0                      |
| Динамічне програмування | Номінал: 50 - 19шт, 25 - 1шт, 10 - 2шт, 2 - 2шт         | 0.00199366               |

## Висновки

### Жадібний алгоритм:
1. **Переваги**:
   - Простота реалізації та виконання.
   - Швидкий час виконання, особливо для невеликих сум.
   - У всіх протестованих випадках надає оптимальне рішення, оскільки номінали монет дозволяють завжди знайти оптимальний розподіл.

2. **Недоліки**:
   - Жадібний алгоритм не завжди гарантує оптимальний результат для всіх можливих наборів номіналів монет.
   - У випадку складніших номіналів монет може бути неоптимальним.

### Алгоритм динамічного програмування:
1. **Переваги**:
   - Завжди знаходить оптимальне рішення для будь-якого набору номіналів монет.
   - Підходить для більш складних випадків, де жадібний алгоритм може бути неоптимальним.

2. **Недоліки**:
   - Може бути складнішим у реалізації порівняно з жадібним алгоритмом.
   - Час виконання може бути трохи більшим, особливо для дуже великих сум.

### Загальні висновки:
- Для набору номіналів монет [50, 25, 10, 5, 2, 1] обидва алгоритми показали однакові результати.
- Жадібний алгоритм швидший і простіший у реалізації, але алгоритм динамічного програмування надає гарантію оптимальності для будь-яких номіналів.
- Вибір алгоритму залежить від конкретних вимог до задачі та набору номіналів монет. У випадку наявності номіналів, які можуть привести до неоптимальних рішень за допомогою жадібного алгоритму, варто використовувати алгоритм динамічного програмування.

