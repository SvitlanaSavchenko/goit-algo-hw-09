## Опис домашнього завдання

У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет `[50, 25, 10, 5, 2, 1]`. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

1. Функція жадібного алгоритму `find_coins_greedy`. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник `{50: 2, 10: 1, 2: 1, 1: 1}`. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.

2. Функція динамічного програмування `find_min_coins`. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник `{1: 1, 2: 1, 10: 1, 50: 2}`

Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл `readme.md` домашнього завдання.

## Критерії прийняття ДЗ

- Прикріплені посилання на репозиторій `goit-algo-hw-09` та безпосередньо сам файл репозиторію у форматі `zip`.
- Програмно реалізовано функцію, яка використовує принцип жадібного алгоритму. Код виконується і повертає словник з кількістю монет кожного номіналу, що використовуються для формування певної суми. Спочатку вибираються найбільш доступні номінали монет.
- Програмно реалізовано функцію, яка використовує принцип динамічного програмування. Код виконується і повертає словник з номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом.
- На основі оцінювання часу виконання кожного з двох алгоритмів або О великого визначено найбільш ефективний при великих сумах алгоритм.
- Зроблено висновки щодо ефективності алгоритмів для даного випадку. Висновки оформлено у вигляді файлу `readme.md` домашнього завдання.

# Висновки щодо ефективності алгоритмів

## Жадібний алгоритм

Жадібний алгоритм швидкий та простий у реалізації. Для певних наборів номіналів, таких як американські монети, він забезпечує оптимальне рішення. Однак, якщо набір номіналів не підходить для жадібного підходу, цей алгоритм може не знайти оптимального рішення.

## Алгоритм динамічного програмування

Алгоритм динамічного програмування завжди знаходить мінімальну кількість монет для будь-якого набору номіналів. Він використовує більше обчислювальних ресурсів, але є більш надійним в умовах, коли жадібний алгоритм не може забезпечити оптимальність.

## Висновок

Для наборів номіналів, де жадібний підхід оптимальний, жадібний алгоритм є ефективним вибором завдяки своїй швидкості. Для інших випадків, де оптимальність важлива, алгоритм динамічного програмування є кращим вибором.

## Порівняння на основі виконання

На основі порівняння часів виконання та результатів роботи алгоритмів для різних сум, можна зробити такі висновки:

- Жадібний алгоритм швидший, але не завжди оптимальний.
- Алгоритм динамічного програмування завжди забезпечує мінімальну кількість монет, але виконується довше.

Наведена таблиця показує результати порівняння:

| Сума | Алгоритм | Час виконання (секунди) |
|------|----------|-------------------------|
| 113  | Жадібний алгоритм  | Результат + Час  |
|      | Динамічне прогр.   | Результат + Час  |
| 289  | Жадібний алгоритм  | Результат + Час  |
|      | Динамічне прогр.   | Результат + Час  |
| 523  | Жадібний алгоритм  | Результат + Час  |
|      | Динамічне прогр.   | Результат + Час  |
| 999  | Жадібний алгоритм  | Результат + Час  |
|      | Динамічне прогр.   | Результат + Час  |
